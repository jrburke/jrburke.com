<!DOCTYPE html>
<html>
<head>
    <title>James Burke</title>
    <link href="https://jrburke.com/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" />
<meta name="viewport" content="width=device-width, initial-scale=1">

<link href="./img/favicon.png" rel="icon">
<link href="./css/index.css" rel="stylesheet" type="text/css">
<script src="./js/index.js"></script>

</head>
<body class="index">
<div class="header">
    <div class="jrbLogo">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 560 980 324">
          <a xlink:href="./" title="home">
              <path class="logoJ" d="M266.127,682.673c-0.123-0.143-3.178-0.303-7.709-0.123l-56.63,0.061l0.093-58.319h-64.494v58.195l-27.488-0.026
	c-1.322-0.053-2.649-0.087-3.985-0.087c-53.177,0-96.285,43.109-96.285,96.285s43.107,96.285,96.285,96.285
	c53.178,0,95.92-43.873,95.92-97.05c0-2.002-0.068-3.986-0.187-5.955l0.05-31.559l37.603-0.346
	c6.609,0.151,13.228-2.215,18.28-7.289C268.131,722.151,266.304,682.878,266.127,682.673z"/>
              <ellipse class="logoDotSpace" cx="169.783" cy="605.491" rx="38.463" ry="38.514"/>
              <circle class="logoDot" cx="169.678" cy="605.652" r="32.095"/>
              <path class="logoLoopSpace" d="M127.305,801.112c-12.627,12.44-33.318,11.246-45.355-1.765c-12.036-13.012-11.4-33.486,1.765-45.355c15.351-13.841,53.381-14.177,53.868-13.623C137.795,740.612,140.108,788.498,127.305,801.112z"/>
              <text x="331.3832" y="737.5167" class="emphasized" font-size="108.4101">james burke</text>
          </a>
        </svg>
    </div>
    <nav id="navMenu" class="closed">
      <div class="topBar">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 930 24" class="topBarItem1">
          <path d="M0 0 L921 0 L930 8 H8 0 Z" class="highlight"/>
        </svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45 24" class="topBarItem2">
          <polygon id="navArrow" points="0,0 23,24 45,0" class="highlight"/>
        </svg>
      </div>
      <div class="bottomSection">
        <div class="menuContainer">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 9.172 36" class="menuItem"> <!-- ABOUT -->
            <a xlink:href="./about/" title="about">
              <text transform="matrix(1 0 0 1 -2.5113 35.9203)" class="emphasized icon" font-size="46">i</text>
            </a>
          </svg>
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 33 33" class="menuItem">  <!-- ARCHIVES -->
            <a xlink:href="./archives/" title="archives">
              <rect width="33" height="33" class="icon"/>
              <rect y="16" class="iconWhiteSpace" width="33" height="1"/>
              <circle class="iconWhiteSpace" cx="16.561" cy="8.037" r="1.501"/>
              <circle class="iconWhiteSpace" cx="16.561" cy="24.484" r="1.501"/>
            </a>
          </svg>
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 53.02 53.046" class="menuItem"> <!-- TAGS -->
            <a xlink:href="./tags/" title="tags">
              <polygon class="icon" points="53.02,14.849 38.171,0 23.718,5.993 0,29.711 23.335,53.046 47.053,29.328 "/>
              <circle class="iconWhiteSpace" cx="38.777" cy="14.104" r="4.001"/>
            </a>
          </svg>
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 36.233 36.608" class="menuItem">  <!-- SEARCH -->
            <a xlink:href="http://duckduckgo.com/?q=site%3Ajrburke.com" title="search">
              <circle class="iconSearch" cx="15.5" cy="15.5" r="13"/>
              <rect x="22.787" y="28.21" transform="matrix(0.7071 0.7071 -0.7071 0.7071 30.1001 -12.248)" width="14.096" height="4" class="icon"/>
            </a>
          </svg>
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 34.006 34.006" class="menuItem"> <!-- FEEDS -->
              <a xlink:href="https://jrburke.com/atom.xml" title="feeds">
                <path d="M0.772,0.309v15.494c0.021-0.002,0.147-0.004,0.407-0.004c0.566,0,0.566,0.01,0,0.01c-0.26,0-0.386-0.002-0.407-0.004
                	v17.446h32.703C33.447,15.147,18.843,0.468,0.772,0.309z" class="icon"/>
                <path class="iconWhiteSpace" d="M22.289,33.286c0.04,0,0.055,0,0.09,0C22.34,21.3,12.718,11.577,0.772,11.368v21.918H22.289z"/>
                <path d="M15.213,33.287c0-0.021,0.003-0.04,0.003-0.061c0-8.102-6.428-14.687-14.461-14.973v15.034H15.213z" class="icon"/>
              </a>
          </svg>
        </div>
        <div class="bottomBar">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 980 22">
              <rect class="highlight" width="980" height="8"/ x="0" y="14">
          </svg>
        </div>
      </div> <!-- END bottomSection -->
    </nav>
</div>
    <div class="section">
        <div class="sectionHeader">
            <h1 class="postTitle"><a href="2016/04/19/the-next-episode/">The next episode</a></h1>
            <div class="datetime" data-datetime="2016-04-19T21:38:06.249Z">
                Tue, 19 Apr 2016 21:38:06 GMT
            </div>
        </div>
        <div class="sectionContent">
            <p>After joining Mozilla Messaging just over seven years ago, I start a new job later this month. I am thankful for <a href="https://infrequently.org/">Alex</a>'s introduction to <a href="http://ascher.ca/">David</a> that led to the Mozilla job.</p>

<p>I moved up to Vancouver to experiment with web-based messaging. That led to a few experiments at Mozilla, most recently the Firefox OS email app front end. However, all the experiments I worked on at Mozilla were eventually shut down. It is time for me to try working on a different kind of project.</p>

<p>I will be cheering on the efforts at Mozilla to improve the browser, and integrate web content better with native platforms via features like service workers and web manifests. I would like to see first class placement of web experiences on native platforms that work well with background updates, offline use. A Mozilla-infused Android distribution with web content front and center, some secure messaging and ties to local communities would be neat to see.</p>

<p>The web rendering developments in <a href="https://servo.org/">Servo</a> are exciting too. Do you want to learn a <a href="https://www.rust-lang.org/">neat language</a> and help them out? Check out the <a href="https://github.com/servo/servo/issues?q=is%3Aopen+sort%3Aupdated-desc+label%3AE-easy">first bugs list</a>. The Rust and Servo communities are really great.</p>

<p>While I appreciate the value of platform work, it is more work for me than the flow I feel when building on web apps. So I am off to work on a web app that helps educators organize their classes. I still plan to do some light open source work on my own time, make sure I keep up maintenance releases for RequireJS related tools. But I will be busy with an exciting new job, and I will not have a lot of left over energy for a while. I will be staying in Vancouver.</p>

<p>Thank you Mozilla, and the people I worked with, for seven years. It changed my life. I recommend <a href="https://careers.mozilla.org/">working at Mozilla</a> particularly if you are a platform or systems developer. Or, just <a href="https://www.mozilla.org/en-US/contribute/">contributing in some way</a> to support the great work of the <a href="https://www.mozilla.org">Mozilla Foundation</a>.</p>
        </div>
    </div>
    <div class="section">
        <div class="sectionHeader">
            <h1 class="postTitle"><a href="2016/03/17/requirejs-2.2-alameda-1.0-released/">RequireJS 2.2, alameda 1.0 released</a></h1>
            <div class="datetime" data-datetime="2016-03-17T19:22:22.207Z">
                Thu, 17 Mar 2016 19:22:22 GMT
            </div>
        </div>
        <div class="sectionContent">
            <ul>
<li><a href="http://www.requirejs.org/docs/download.html">RequireJS 2.2</a></li>
<li><a href="https://github.com/requirejs/alameda/releases">alameda 1.0</a></li>
</ul>

<p>RequireJS has a new <strong>minor</strong> version rev, prompted by a couple things:</p>

<p>1) The RequireJS project has transitioned over to the jQuery Foundation. New legal stuff for the copyright, and now just MIT license vs both MIT and BSD 2 dual license. According to the lawyer advice, MIT on its own is more permissive than BSD 2, so it should be a superset of all the possible use cases when BSD 2 might be used in the consuming project. Same permissable, free use as before, just simpler on the license front.</p>

<p>If you want to contribute to the codebase, you can <a href="http://requirejs.org/docs/contributing.html">sign the jQuery Foundation CLA</a>, which is generally useful. It clears the path for contributing to all of the other great jQuery Foundation projects.</p>

<p>2) Some larger changes for some new features. It should all be backwards compatible, but with the addition of the new features, it felt appropriate to indicate this was more than a patch version release.</p>

<p>This is not the same 2.2 release that I had in the planning phases for a couple of years, just a recalibration on existing needs, and wanting to better follow <a href="http://semver.org/">semver</a>.</p>

<h2 id="notablerequirejsloaderchangeshttpsgithubcomrequirejsrequirejsissuesqmilestone3a220is3aclosed"><a href="https://github.com/requirejs/requirejs/issues?q=milestone%3A2.2.0+is%3Aclosed">Notable RequireJS loader changes</a></h2>

<h3 id="urlargscanbeafunctionhttprequirejsorgdocsapihtmlconfigurlargs"><a href="http://requirejs.org/docs/api.html#config-urlArgs">urlArgs can be a function</a></h3>

<p>This allows finer tuning of querystring arguments, for things like different version strings for different files.</p>

<h3 id="pluginidsfordatamainhttpsgithubcomrequirejsrequirejsissues1472"><a href="https://github.com/requirejs/requirejs/issues/1472">plugin IDs for data-main</a></h3>

<p>This sort of data-main value works now:</p>

<pre><code class="language-markup">&lt;script src="require.js" data-main="lib/bootstrap!app/main"&gt;&lt;/script&gt;
</code></pre>

<p>This assumes the baseUrl is the directory that holds the HTML document, in order to find the loader plugin.</p>

<h2 id="notablerjsoptimizerchangeshttpsgithubcomrequirejsrjsmilestones220"><a href="https://github.com/requirejs/r.js/milestones/2.2.0">Notable r.js optimizer changes</a></h2>

<h3 id="fasterhttpsgithubcomrequirejsrjspull900"><a href="https://github.com/requirejs/r.js/pull/900">Faster!</a></h3>

<p>Thanks to the great work by <a href="https://github.com/petersondrew">@petersondrew</a>, build times are noticeably faster. Your mileage will vary depending on the type of project, but the r.js test suite runs almost twice as fast under Node.</p>

<h3 id="uglify2isnowthedefaultminifier">Uglify2 is now the default minifier</h3>

<p>Before 2.2, <code>optimize: 'uglify'</code> used UglifyJS 1.3.x, where <code>uglify2</code> used UglifyJS 2. This was a result of the optimizer just being around a long time, during the uglify transition to their version 2 codebase. Now that version 2 is the standard UglifyJS codebase, the use of version 1 as a default was confusing.</p>

<p>So version 1 was removed from the optimizer, and now just version 2 is used. No need to update your build config. If you use <code>uglify2</code> as the optimize value, it will still work. Now the <code>uglify</code> value uses version 2 too.</p>

<h3 id="generatebundlesconfighttprequirejsorgdocsapihtmlconfigbundles"><a href="http://requirejs.org/docs/api.html#config-bundles">Generate bundles config</a></h3>

<p>If you want to use <a href="http://requirejs.org/docs/api.html#config-bundles">bundles config</a>, the optimizer can now generate the bundle config and insert it into a requirejs.config() call via the <code>bundlesConfigOutFile</code> config option.</p>

<h2 id="alternatives">Alternatives</h2>

<p>I am mostly trying to keep the RequireJS codebase fairly static, no big changes.</p>

<p>If you do want to use loader that has a more modern, smaller codebase, try <a href="https://github.com/requirejs/alameda">alameda</a>. That is the codebase I would like to maintain for an AMD loader going forward, and where I would consider larger structural changes.</p>

<p>If you want to do fancier custom build processes, look at <a href="https://github.com/amodrojs/amodro-trace">amodro-trace</a>. It provides a programmatic API for use in Node programs for just tracing and normalizing AMD modules.</p>

<h2 id="pastandfuture">Past and future</h2>

<p>The primordial parts of the RequireJS loader started to take form in September 2009, with many usable releases through October 2011, when 1.0 was tagged. It is now 2016.</p>

<p>So, 6 &amp; 1/2 years. I was hoping the need for these userland loaders would just last for a few years then a native loader and module system would obsolete the need for them. Funny how our desires for the future often outpace reality.</p>

<p>I am still hopeful that will happen at some point, so I am not investing a lot of energy to reimagining how an AMD loader might work. I would like to see a native module system actually ship before seeing if it made sense to make new tools around it.</p>

<p>That said, I like the smaller, modern core of alameda. I look forward to using it if a project calls for an AMD loader, although I am happy to work on projects that would not require it.</p>

<p>I want to keep the RequireJS codebase fairly stable. I still expect to do occasional patch version releases for RequireJS, maybe 2-3 a year. Particularly since alameda has a higher barrier to use: promise support in the browser and IE10+ for script loading. As time moves forward though, those constraints should be less of a concern.</p>

<p>I will not post here about every point release for the loaders. These places track the releases:</p>

<ul>
<li><a href="http://requirejs.org/docs/download.html#releasenotes">RequireJS release notes</a></li>
<li><a href="https://github.com/requirejs/alameda/releases">alameda releases</a></li>
</ul>

<p>Thanks for your time and use of the libraries. The goal for them was to be useful, help inform the future. They have lived longer than I would have wagered at the beginning. Here's to hoping they are not around for another 6 &amp; 1/2 years! Please hasten their retirement by finishing a native JS module system!</p>
        </div>
    </div>
    <div class="section">
        <div class="sectionHeader">
            <h1 class="postTitle"><a href="2016/01/19/template-strings-components-models-and-events/">Template strings, components, models and events</a></h1>
            <div class="datetime" data-datetime="2016-01-20T06:26:35.443Z">
                Wed, 20 Jan 2016 06:26:35 GMT
            </div>
        </div>
        <div class="sectionContent">
            <p><em>This is a shorter, rougher post to outline a recent experiment around UI construction. It is a bit high level, and sets some context around the <a href="https://github.com/jrburke/htemplate">htemplate</a> module</em>.</p>

<p>Some nice things about the <a href="https://facebook.github.io/react/">React</a>-related world that I wanted to try for a work project:</p>

<ol>
<li>A component system.</li>
<li>Grouping the DOM building with the JS code that knows about the state (In React, this is the render method, using <code>React.createElement</code> or <a href="https://facebook.github.io/react/docs/displaying-data.html#jsx-syntax">JSX</a>).</li>
<li>From Flux, enforcing visual updates to be triggered from model changes, not from other visual components.</li>
</ol>

<p>However, because of cultural constraints and an interest to keep the up front cost small, keep the stack small and shallow, I wanted to avoid a virtual DOM implementation and a transpiler.</p>

<p>What I ended up using:</p>

<ol>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Custom_Elements">Custom elements</a>. This makes sense for the work project since we want to test out the custom element API, help find bugs. Custom elements are enabled by default for the project, so no special shims or adapters are necessary.</p></li>
<li><p><a href="https://github.com/jrburke/htemplate">htemplate</a>: uses <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/template_strings#Tagged_template_strings">tagged template strings</a> to allow grouping the state logic in JS with building up the DOM. I get to use ES2015 without needing any build transforms to translate it to ES5, and I wanted to avoid the JSX transforms.</p></li>
<li><p>Adopt a cultural practice of calling the model API, then wait for the model object to update and bind the re-rendering of the custom element to events emitted from the model. The custom elements directly subscribe to the model to get changes instead of passing state down through components via a top level component.</p></li>
</ol>

<p>In order to not take the cost of re-rending stuff that has not changed, the UI would be broken down into smaller custom elements that listened for fine-grained model updates.</p>

<p>This is possible because we have a front end object, called <code>model</code> which sits in front of the core backend model API, and if we notice that we need to group or constraint model update events to help scope visual updates, we have a place to do that.</p>

<p>A similar idea is behind <a href="https://github.com/facebook/graphql">GraphQL</a> and <a href="https://github.com/Netflix/falcor">Falcor</a>, but this approach was done without a formal query language: construct a way to only see part of the whole model, scope data update events to subsets. Model properties/event names were used as the scoping mechanism.</p>

<h2 id="customelementconstruction">Custom element construction</h2>

<p>This can be done in any number of ways, but I was already using <a href="https://github.com/jrburke/element"><code>element</code></a>, so I just continued with it. However, I did not need to use the <a href="https://github.com/jrburke/element#template-loader-plugin-custom-features"><code>template</code></a> module, instead <a href="https://github.com/jrburke/htemplate"><code>htemplate</code></a> was used to construct the DOM within the components.</p>

<p><code>element</code> supports building up the custom element prototype via mixins instead of inheritance, and if multiple mixins define methods for the <a href="https://github.com/jrburke/element#element-lifecycle-background">custom element lifecycle</a>, <code>element</code> will chain them together.</p>

<h2 id="modelconstruction">Model construction</h2>

<p><code>model</code> is an object that mixes in an event emitter. There are lots of choices for event emitters. I used <a href="https://github.com/jrburke/evt"><code>evt</code></a> because it supports a <code>.latest()</code> concept, where it will call the listener if there is a current value for the event property, and for any future updates.</p>

<h2 id="bindingthemodeltotheview">Binding the model to the view</h2>

<p><code>element</code> mixins are used to bind the model updates to a <code>render()</code> method on the component. A sample of the end result:</p>

<ul>
<li><code>base_render</code> sets up the relationship between htemplate and the model.</li>
<li><code>['accounts', 'folders']</code> are the model properties that this component wants to get updates about.</li>
<li>The function is the "renderFn" given to <code>htemplate</code>.</li>
<li>The html`` part is the tagged template string created by htemplate.</li>
<li>The model object is passed to the custom element as <code>this.model</code>.</li>
</ul>

<pre><code class="language-javascript">{
  render: require('../base_render')(['accounts', 'folders'], function(html) {
    var currentAccount = this.model.account;
    if (!currentAccount) {
      return;
    }

    html`
    &lt;a data-prop="accountHeader"
       data-dclick="toggleAccounts"
       class="fld-acct-header closed" role="region"&gt;
      &lt;span class="fld-acct-header-account-label"&gt;${currentAccount.name}&lt;/span&gt;
      &lt;span class="fld-acct-header-account-header"
            data-l10n-id="drawer-accounts-header"&gt;&lt;/span&gt;
      &lt;span class="fld-account-switch-arrow"&gt;&lt;/span&gt;
    &lt;/a&gt;
    &lt;div data-prop="fldAcctScrollInner" class="fld-acct-scrollinner"&gt;
      &lt;div data-prop="fldAcctContainer" class="fld-acct-container"&gt;
        &lt;!-- The list of accounts --&gt;
        &lt;div data-prop="accountContainer"
             data-dclick="onClickAccount"
             class="fld-accountlist-container collapsed"&gt;
        `;

        // Add DOM for each account.
        if (this.state.accounts) {
          this.state.accounts.items.forEach((account) =&gt; {
            // Highlight the account currently in use
            var selectedClass = this.model.account &amp;&amp;
                                this.model.account.id === account.id ?
                                'fld-account-selected' : '';

            html`
            &lt;a class="fld-account-item ${selectedClass}"
               data-account-id="${account.id}"&gt;
              &lt;span class="selected-indicator"&gt;&lt;/span&gt;
              &lt;span class="fld-account-name"&gt;${account.name}&lt;/span&gt;
            &lt;/a&gt;
            `;
          });
        }

        html`
        &lt;/div&gt;
        &lt;!-- The list of folders for the current account. --&gt;
        &lt;div data-prop="foldersContainer"
             data-dclick="onClickFolder"
             class="fld-folders-container"&gt;
        `;

          if (this.state.folders) {
            this.state.folders.items.forEach((folder) =&gt; {
              var extraClasses = [];

              if (!folder.selectable) {
                extraClasses.push('fld-folder-unselectable');
              }

              var depthIdx = Math.min(FOLDER_DEPTH_CLASSES.length - 1,
                                      folder.depth);
              extraClasses.push(FOLDER_DEPTH_CLASSES[depthIdx]);
              if (depthIdx &gt; 0) {
                extraClasses.push('fld-folder-depthnonzero');
              }

              if (folder === this.model.folder) {
                extraClasses.push('fld-folder-selected');
              }

              html`
              &lt;a class="fld-folder-item ${extraClasses.join(' ')}"
                 data-type="${folder.type}"
                 data-folder-id="${folder.id}"&gt;
                &lt;span class="selected-indicator"&gt;&lt;/span&gt;
                &lt;span dir="auto"
                      class="fld-folder-name"&gt;${folder.name}&lt;/span&gt;
                &lt;span class="fld-folder-unread"&gt;&lt;/span&gt;
              &lt;/a&gt;
              `;
            });
          }

        html`
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    `;
  })
}
</code></pre>

<p>If the accounts or folders update frequently, then I could create smaller custom elements that focus on displaying those pieces based on the individual model property changes. However, for the time that this UI is shown, those model properties will rarely change, so inlining the work to show both lists in one component is fine.</p>

<h2 id="htemplatenotes">htemplate notes</h2>

<p>htemplate supports passing non-string values to sub-elements by setting a property on the sub-element instead of setting a string attribute. This is useful to pass down objects, like the <code>model</code> object, to sub-elements. More details in the <a href="#https://github.com/jrburke/htemplate#property-setting">Property setting section of the htemplate readme</a>.</p>

<p>Editor support for syntax highlighting HTML inside the tagged template strings helps with the string legibility. It would be great to get more editors supporting it as I expect it will become  more common as tagged template strings get more visibility. Here are a couple of issues tracking that for different editors:</p>

<ul>
<li><a href="https://github.com/atom/language-javascript/pull/282">Atom editor</a></li>
<li><a href="https://github.com/Benvie/JavaScriptNext.tmLanguage/issues/134">Sublime Text, JavaScriptNext.tmLanguage package</a></li>
</ul>

<p>If you can, help your editor improve the display of a HTML string templates.</p>

<h2 id="summary">Summary</h2>

<p>I like the feel of it so far. As with most technology choices, it is about the tradeoffs you can accept.</p>

<p>I am fortunate to be able to use ES2015 and custom elements natively, not an option for many projects. It is fun to play in the future natively, I am excited to see those pieces become widely available across browsers.</p>

<p>Not using a virtual DOM implementation requires more thought on rate of updates for a component. Instead of just letting a React render pass sort out the details, The rate of model update events should be considered more, and possibly creating smaller components that care about finer grained model updates.</p>

<p>A virtual DOM can allow the developer to be more carefree about this, at the possible cost of React creating a larger set of internal objects to do a diff when the model changes only affect a small portion of the UI.</p>

<p>There are some cases where I do not want to just blast the innerHTML of the custom element on every model update. For instance, a CSS animated spinner that is activated by a class change to an element. In that case, I do not want to reset the innerHTML as the animating spinner would appear to jump around and reset. In those cases the custom element may decide to check if the existing DOM has the class set correctly instead of always resetting the innerHTML. A more manual diff model.</p>

<p>On the flip side, those cases are small and scoped, and the overall bootstrap code size of the project is smaller, with less build machinery in place.</p>

<p>So, tradeoffs. To be clear, the React ecosystem has a lot to offer, but it has been fun exploring an alternate approach inspired by some aspects of it but with different tradeoffs.</p>
        </div>
    </div>
    <div class="section">
        <div class="sectionHeader">
            <h1 class="postTitle"><a href="2015/04/09/amodro-trace-and-amd-loaders/">amodro-trace and AMD loaders</a></h1>
            <div class="datetime" data-datetime="2015-04-09T20:26:35.414Z">
                Thu, 09 Apr 2015 20:26:35 GMT
            </div>
        </div>
        <div class="sectionContent">
            <p>A new tool, and some AMD loader rambling:</p>

<p>I have started a new project around AMD modules, <a href="https://github.com/amodrojs/amodro-trace">amodro-trace</a>. It is a tool that understands AMD modules and is meant to be used in other node-based build systems. The README has more background, but the general use cases that drove it:</p>

<ul>
<li>Get a dependency tree for a module ID</li>
<li>Allows non-file inputs</li>
<li>Allows transpiling inputs to AMD before tracing</li>
<li>Allows content transforms after AMD normalization</li>
</ul>

<p>Think of amodro-trace as a lower level imperative tool that something like the requirejs optimizer could use to implement its declarative API.</p>

<p>amodro-trace comes from some code in the requirejs optimizer, and has some smaller unit tests. I ran it over a larger project, but still expect to fine tune some things around API and operation, so feel free to give feedback in the issues list if the use cases fit your needs but have trouble using it.</p>

<p>I would also like to construct a new AMD loader, something that assumes more modern browsers and can improve on some things learned from requirejs.</p>

<p>I do not expect requirejs to go away any time soon, and it will still be my recommendation for general AMD loading across a wide set of browsers. There will still be maintenance releases, but I expect to do any new work that non-trivially modifies behavior to be done under a new name. This helps set stable expectations, particularly for tools that have been built on top of requirejs.</p>

<p>I still want to explore some things with AMD loaders though, particularly since an <a href="http://jrburke.com/2015/02/13/how-to-know-when-es-modules-are-done/">operational ES module system is still far off</a>, and transpilers that guess at ES module syntax still benefit from good AMD loader options to back them.</p>

<h2 id="amdloaderoptions">AMD loader options</h2>

<p>First, a bit about some AMD loader options that I have worked on. The nice thing about AMD modules is that there are more options besides this set, and other tooling around them. This is just about where and how I have spent my time in this space.</p>

<ul>
<li><a href="http://requirejs.org/">requirejs</a>: the baseline loader. Along with its <a href="http://requirejs.org/docs/optimization.html">optimizer</a>, it has a fairly large set of tests and stability. (Side note: the code that would become requirejs started in 2009, first releases in 2010, with some ideas stretching back much earlier from Dojo.)</li>
<li><a href="https://github.com/requirejs/cajon">cajon</a>: Built around requirejs, but bundles an XHR fetch option to allow for consuming CommonJS modules directly as well as AMD modules. Comes with the caveats of using an XHR loader though, like <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS">CORS</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/Security/CSP/Introducing_Content_Security_Policy">CSP</a> issues.</li>
<li><a href="https://github.com/requirejs/alameda">alameda</a>: Like requirejs, but assumes more modern browsers as a baseline (mainly means does not support IE9 and below), uses promises under the hood. There is a <a href="https://github.com/requirejs/alameda/tree/native-promise">native-promise</a> branch that does not use a promise shim, just native browser promises. alameda is used by some <a href="https://github.com/mozilla-b2g/gaia">Gaia</a> apps that use modules.</li>
<li><a href="https://github.com/jrburke/module">module</a>: Not AMD, but what I imagine a module system would look like given what we have learned from CommonJS and AMD modules, and assuming a browser loader capability that avoids CORS/CSP issues for text fetching and evaluation. While a useful exercise, and more operational and fleshed out than an ES system, more of an experimental playground.</li>
</ul>

<h2 id="amodroloader">amodro loader</h2>

<p>For a new AMD loader, I am thinking of putting it under the amodro (pronounced a-mo-dro) name. amodro-trace is the start of what I would see as its equivalent of the requirejs optimizer piece. amodro-trace currently uses requirejs under the hood for module tracing, but ideally that would migrate over time to a new loader.</p>

<p>I would not want to modify any of the AMD APIs for declaring a module or for the dynamic require calls. So no changes in module syntax to allow the most reuse of existing AMD modules.</p>

<p>However, I want to rethink some of the loader APIs and loader plugin APIs to do something like what an older draft of the ES-related loader had for a module lifecycle: normalize, locate, fetch, translate, instantiate. The loader plugin API as supported in requirejs-like loaders is not as granular, and supporting a more granular API would help with some issues that have come up with the loader plugins to date: it can be hard to break cycles for some loader plugins, and can make building more complicated.</p>

<p>The <code>module</code> loader mentioned above makes an attempt at that sort of solution for loader plugins, and it works out well. There is a good chance existing loader plugins would still work too since their APIs can be seen as a coarser API that could be supported by the more granular API. Still a bit of work to be done there, but it seems promising.</p>

<p>So I expect amodro would be like the <code>module</code> loader, but designed to work with the AMD APIs instead of the <code>module</code> API in that loader, and probably using some of the alameda ideas too.</p>

<p>I may not get to it though. Just sharing my thoughts around loader work. I have a day job that I really like, and we are doing some interesting work. There are some (non-loader) ideas I want to implement there, and I am excited to try out service workers in that context.</p>

<p>The <a href="http://dojotoolkit.org/">Dojo folks</a> are also thinking about this space, as well as <a href="http://unscriptable.com/">John Hann</a> and <a href="http://tbranyen.com/">Tim Branyen</a>, so other options may come out of their efforts too. It is good to have options.</p>

<p>End result, more in this space worth pursuing.</p>

<h2 id="moreconventionoverconfiguration">More convention over configuration</h2>

<p>For AMD projects in general, and something that does not depend on any new loader work:</p>

<p>We can help improve the perception of difficulties with configuration by starting to advocate more for standard project layouts that avoid big configuration blocks for the loader. Effort in this space would likely benefit an ES module solution too, as it will need to operate in the same async network space that AMD modules operate.</p>

<p>To me, that means using a starting project layout that looks like <a href="https://github.com/volojs/create-template">this sample project</a>. The <code>lib</code> directory could be a <code>node_modules</code> or <code>bower_components</code> directory.</p>

<p><a href="https://github.com/jrburke/adapt-pkg-main">adapt-pkg-main</a> can be used after an npm/bower install to fix up the installed dependency to work with the file layout convention that works best for general web module loading, without running into CORS or 404 issues.</p>

<p>Then hopefully the package managers get better about these file layouts over time (maybe absorb what adapt-pkg-main does), and in the case of npm, <a href="https://github.com/jrburke/notobo/blob/master/docs/npm-sharp-edges.md">remove some sharp edges</a> for front end development.</p>

<h2 id="summary">Summary</h2>

<p>You might try <a href="https://github.com/amodrojs/amodro-trace">amodro-trace</a> if its use cases fit your needs. While it comes from some code that has had a good amount of testing, it is still a new approach on it and may have some bugs, so I am keeping the version low for now. However, it is the kind of AMD build tool I would like to support longer term: provide a primitive focused solely on the AMD tracing and normalization so that others can build on top of it.</p>

<p>The requirejs optimizer was built at a time when node was not a thing yet, and more batteries needed to be included for command line JavaScript tooling. It has been a good approach for the requirejs optimizer: it runs in node, Nashorn, Rhino, xpcshell and even in the browser. It gives a bunch of communities a chance at some good AMD-based optimization options.</p>

<p>However, I do not expect to keep pace with all the possible variations in build tool styles with the requirejs optimizer's more declarative options-based approach. amodro-trace should be helpful for those cases.</p>

<p>Here's to more AMD loaders and tools for the future!</p>
        </div>
    </div>
    <div class="section">
        <div class="sectionHeader">
            <h1 class="postTitle"><a href="2015/02/13/how-to-know-when-es-modules-are-done/">How to know when ES modules are done</a></h1>
            <div class="datetime" data-datetime="2015-02-13T21:49:08.820Z">
                Fri, 13 Feb 2015 21:49:08 GMT
            </div>
        </div>
        <div class="sectionContent">
            <p>There are few pieces of a module system that need to be available for it to be fully functional. I will describe them here and talk a bit about where ECMAScript (ES) modules seem to be at the moment, from an outside public perspective.</p>

<p>I am not on TC-39, the committee that works on the ES language specification (otherwise known as JavaScript, JS). Just someone who has worked on <a href="http://dojotoolkit.org/">a</a> <a href="https://github.com/requirejs/cajon">few</a> <a href="http://requirejs.org/">JS</a> <a href="https://github.com/requirejs/alameda">module</a> <a href="https://github.com/jrburke/module">systems</a>.</p>

<p>This is a long piece. A table of contents for the top level sections:</p>

<ul>
<li><a href="#modulesystempieces">Module system pieces</a></li>
<li><a href="#interlockingpieces">Interlocking pieces</a></li>
<li><a href="#wherearewenow">Where are we now?</a></li>
<li><a href="#hazardsonthewaytodone">Hazards on the way to done</a></li>
<li><a href="#summary">Summary</a></li>
</ul>

<h2 id="modulesystempieces">Module system pieces</h2>

<p>There are three main pieces of a module system:</p>

<ul>
<li><a href="#staticmoduledefinition">Static module definition</a></li>
<li><a href="#executiontimemodulecapabilities">Execution-time module capabilities</a></li>
<li><a href="#moduleloader">Module loader</a></li>
</ul>

<p>Some might argue that these pieces are separable and could be specified by different standards groups. So an "ES module system" may not be the right term, as ES may only specify one or two pieces.</p>

<p>For me, they are all part of a coherent module system, so I will be referring to the future direction for them as the "ES module system", even if the URLs for each specification end up on different domains.</p>

<h3 id="staticmoduledefinition">Static module definition</h3>

<p>This is how you statically declare a piece of code as a module with dependencies. In this context <strong><em>static</em></strong> means: does not change depending on the execution environment. Static dependencies can be parsed out of a module without actually running the module in a JS environment, the loader just needs to parse the text of the module to find them.</p>

<p>In AMD modules, it looks like this:</p>

<pre><code class="language-javascript">define(function(require, exports, module) {
  // Statically parsable dependencies.
  var glow = require('glow'),
      add = require('math').add;
});
</code></pre>

<p>In CommonJS and Node (for shorthand's sake referred to as "CJS" for the rest of this post), there is a similar idea, just without the define() wrapper.</p>

<p>It is a bit more nuanced in CJS systems: the require(StringLiteral) calls are not parsed prior to execution, one of the major reasons that format is not fully suitable for a full module system on the front end, where async networking is involved. You can get some front end functionality by using something like browserify or webpack to do the static search for dependencies, but just for bundling. Fine enough for libraries but starts to break down on the app level where you want to incrementally load functionality as the user goes to use it, use a dynamic router.</p>

<p>In ES, it looks like this currently:</p>

<pre><code class="language-javascript">// Statically parsable dependencies.
import glow from 'glow';
import { add } from 'math';
</code></pre>

<p>ES also statically indicates the named export keys too:</p>

<pre><code class="language-javascript">// Statically parsable dependencies.
import glow from 'glow';
import { add } from 'math';

// Statically indicate this module will have a 'default'
// and 'other' export keys.
export default function() {};
export other funtion() {};
</code></pre>

<p>While this helps statically match up any keys given to the exported values to the ones used in import statements, the export value is not statically exported, just an indication of its name.</p>

<p>For AMD/CJS systems, there really is just one exported value per module, but it could be an object with multiple properties. There is no static analysis of the export value in those systems.</p>

<p>This part of the ES module system is the piece that is the most specified at the moment.</p>

<h4 id="inlinemodules">Inline modules</h4>

<p>However, the ES system does not allow for what will be called "inline modules" for the purposes of this post. Inline modules are just the ability to statically declare more than one module in a file. This is commonly used for bundling modules together, but <a href="https://github.com/jrburke/module/blob/master/docs/inlining.md">has other purposes</a>.</p>

<p>In AMD, those are just named <code>define()</code>s:</p>

<pre><code class="language-javascript">define('glow', function(require, exports, module) {
  return function glow() {
  };
});

define('app', function(require, exports, module) {
  // Statically declare dependencies.
  var glow = require('glow'),
      add = require('math').add;
});
</code></pre>

<p>For CJS, there are conventions for doing this via tools like browserify and webpack, but they are much less declarative. The module IDs are converted to array indices/numbers. This makes dynamic module loading harder.</p>

<p>For ES there is nothing for this. The last I heard, the hope was for capabilities like HTTP2 and zip bundles so that no new language syntax is needed, however I believe <a href="https://github.com/jrburke/module/blob/master/docs/inlining.md">that is not sufficient</a>.</p>

<p>In the AMD/CJS world, it has become more common to deal with nested groups of modules bundled together. An example would be some browserified base libraries that are then combined with some AMD modules in an app. The browserified ones have a conceptual inner module structure that should not be visible outside the module.</p>

<p>AMD and CJS do not do well with this right now. I have considered supporting something like this in my AMD loaders to allow for it:</p>

<pre><code class="language-javascript">define(function(require, exports, module, define) {
  // The define passed in here is a local
  // define for modules only visible to
  // this module.
});
</code></pre>

<p>There are some interesting characterstics around how to define the module this way when it can have async resolved dependencies. That has been more fully explored in <a href="https://github.com/jrburke/module">this module experiment</a>, so I believe it can work.</p>

<p>The end result, I see modules now as units of code that can be nested. Similar to how functions work, but instead of identifiers for names, module ID strings are used, and their export may be resolved asynchronously, so a bit of syntax is needed for that.</p>

<p>The other option I have heard for ES would be to compile down the module into ES5 code, and use the ES module loader lifecycle hooks to get that into an ES6 module loader.</p>

<p>That option looks like a leaky abstraction. In addition, there are some tricks with the way ES6 imports are mutable slots and the syntax around getting to the execution-time module capabilities that require some extra thought.</p>

<h3 id="executiontimemodulecapabilities">Execution-time module capabilities</h3>

<p>There are some properties and capabilities that need to be exposed during the execution of a module. This means it cannot be statically determined, it is only known once the module is executing in a JS engine.</p>

<p>In the AMD world, the execution-time capabilities come in these forms:</p>

<ul>
<li><code>module.id</code> - the module's normalized ID for the module loader instance.</li>
<li><code>module.url</code> - the URL or path to the module.</li>
<li><code>require([aJsStringValue], function(c) {})</code> - dynamically get a handle on modules. Load them if need be, but in the loader that loaded this module. Should also handle relative IDs.</li>
<li><code>require.toUrl('./d')</code> - Converts module ID './d' to a full path, useful for assets related to the module, like images or style sheets.</li>
</ul>

<p>In Node:</p>

<ul>
<li><code>module.id/module.url</code> - they end up being the same, but conceptually should be different.</li>
<li><code>__filename</code> - could be derived from module.url.</li>
<li><code>__dirname</code> - could be derived from module.url.</li>
<li><code>require(aJsStringValue)</code> - dynamically, synchronously load and execute module in the loader that loaded this module.</li>
<li><code>require.resolve(AJsStingValue)</code> - converts module ID to a path.</li>
</ul>

<p>(Synchronous return from that dynamic require is one of the reasons the CJS system is not the right fit for a general purpose front end module system in the browser.)</p>

<p>In ES, this piece is not formally specified yet. In the ES world, I believe this is referred to as the "module meta", if you come across that phrase. The most recent hint of how it might be done in ES looked something like:</p>

<pre><code class="language-javascript">import local from this;
console.log('Normalized module ID is: ' + local.id);
console.log('Normalized module URL is: ' + local.url);
local.import(aJsStringValue).then(Function(someModule) {});
</code></pre>

<p>I am making up the name of the properties for id, url, and import. I am not sure what their real names will be, just that <code>from this</code>, or some <code>from</code>-based form, was being considered as the way to aquire this functionality.</p>

<h3 id="moduleloader">Module loader</h3>

<p>This is an API that runs at execution time. It kicks off module loading, and allows ways to resolve module IDs to paths, handles the loading and proper execution order of the modules, caches the module values.</p>

<p>In AMD, the main module loader API is <code>require([String], function(e) {})</code>. There is usually something like <code>require</code> for top-level, default loader loading, and each module can get its own local <code>require</code>. Some AMD loaders can create multiple module loader instances.</p>

<p>It is common for AMD loaders to support the idea of a loader plugin, a module that provides a <code>normalize</code> and <code>load</code> method that are plugged in to the AMD loader's <code>normalize</code> and <code>load</code> lifecycle steps.</p>

<p>This allows extending the base loader to handle transpiled code without requiring plugins to be loaded up front, before main module loading starts.</p>

<p>In CJS, <code>require(String)</code> is the main API to the module loader. There is a way to extend the loader capabilities via <code>require('module')._extensions['.fileExtension'] = function() {}</code>. This requires the extension to be installed before modules that depend on it are loaded. This works fine in Node's synchronous module execution environment, but does not translate to async loading in the browser.</p>

<p>For ES, this part is still being defined. There was a <a href="https://github.com/jorendorff/js-loaders">previous sketch for it</a>, but it seems like that is being redone now. I do not feel it is useful to link to the current attempt at the sketch because it is incomplete, and they likely want to work on it themselves to get it in a more usuable state before getting a lot of feedback about it.</p>

<p>The previous sketch did have the concept of a module loading lifecycle, and a way for userland code to plug in to that lifecycle, and I can see this concept carrying forward in some fashion:</p>

<ul>
<li><code>normalize</code>: normalize module IDs.</li>
<li><code>locate</code>: translating an ID to a URL/path.</li>
<li><code>fetch</code>: getting the text contents of the module from the URL/path.</li>
<li><code>translate</code>: allows translating the text into JavaScript that can be executed.</li>
<li><code>instantiate</code>: allows a way for legacy module syntaxes to be converted into a form usable by the ES loader.</li>
</ul>

<p>The granularity of these steps are better than the ones in AMD loader plugins, which just have a concept of <code>normalize</code> and <code>load</code>. <code>load</code> is really <code>locate</code>, <code>fetch</code>, <code>translate</code>, <code>instantiate</code> in one method. It would be good to have more granular steps.</p>

<p>However, there was no built in way in the ES loader to know how to load the hooks as part of normal module loading.</p>

<p>For AMD systems, module IDs of the form <code>pluginId!resourceId</code> meant the loader would load the module for <code>pluginId</code>, then wire it into the loader lifecycle, then delegate to that plugin's lifecycle methods for IDs that begin with <code>pluginId!</code>.</p>

<p>That approach avoids a two-tiered loading system in a web page where the all the loader plugins are loaded first, and then continue with the rest of module loading. The two tiered approach is slower and breaks encapsulation. Any package that used a loader plugin would need to somehow get the plugin registered in the correct loader instance up front. It also gets tricky if those loader plugins have regular JS module dependencies.</p>

<h2 id="interlockingpieces">Interlocking pieces</h2>

<p>While the three pieces of a module system could in some way be considered separate, they all have interlocking pieces, and those pieces need to fit well together.</p>

<h3 id="moduleids">Module IDs</h3>

<p>The rules around the module IDs needs to be understood for the pieces to work well together. If someone is just working with the static module definition part and just uses a plain path for the ID, that will likely conflict with the module loader part, since the IDs should be separate string concepts from paths to support conceptual string namespaces for things like loader plugins and packages that do not have direct path equivalents.</p>

<h3 id="loaderextensions">Loader extensions</h3>

<p>This is tied a bit into the module ID coordination, but also involves module loader load order and how much a given module needs to know about how loader extensions (like transpilers) get wired into the system.</p>

<p>One option is to say that is something that is configured and wired up separately from the modules themselves, out of band, like via package config and some coordinated way to get those registered with a loader up front. This breaks encapsulation though, and makes it hard for the plugins to use modules for their own dependencies. The loader plugin approach in AMD is a much more sane way to go about it.</p>

<h3 id="executiontimemodulecapabilitiesvsstaticmoduledefinition">Execution-time module capabilities vs static module definition</h3>

<p>In the ES sketch above, <code>from this</code> for the execution-time module capabilities is a specific language construct that needs to be built into the static module definition.</p>

<h3 id="loadersandexecutiontimemodulecapabilities">Loaders and execution-time module capabilities</h3>

<p>The execution-time module capabilities also relate to methods on the module loader, like the capability to dynamically load code.</p>

<h2 id="wherearewenow">Where are we now?</h2>

<p>I believe the plan is for the ES6 spec is to just contain the static module definition piece, and for the other bits to be specified in separate specifications coming later.</p>

<p>The trouble is people are starting to use the static module definition piece via transpilers, but without having the other interlocking pieces sorted out.</p>

<p>The transpilers often just compile down to AMD or CJS modules for actual use, and these have some differences with the likely final ES plan. The main issues are:</p>

<h3 id="moduleidsarenotsortedout">Module IDs are not sorted out</h3>

<p>AMD has a stricter separation to module ID vs path, where CJS as practiced in Node is more file path based. IDs really need to be different things than paths. For regular JS modules, they can have an easy simple transform to a path, but need to be conceptually different.</p>

<h3 id="exportmodelsaredifferent">Export models are different</h3>

<p>The ES export module is different than AMD/CJS. In ES all exports are named. The name <code>default</code> just has some extra syntax sugar for <code>import</code>, but no sugar when the module is referenced via the execution-time module capabilities. Expect to be typing <code>.default</code> for that.</p>

<p>AMD/CJS exports are really just single exports, but those systems are nice enough to create an export object if you want to use the <code>exports.foo = ''</code> form of adding properties to the export object.</p>

<h3 id="noexecutiontimemodulecapabilities">No execution-time module capabilities</h3>

<p>There is no ES specification for the execution-time module capabilities. So there is no way with the ES syntax and APIs to build a dynamic router. You will need to know the AMD/CJS system you are using underneath to do that part.</p>

<p>What is meant by "dynamic router"? A module that looks at a piece of runtime path information (typically a URL segment), then translates that to a module ID for a view and dynamically loads that view via module APIs (either <code>require([varName])</code> in AMD or <code>require(varName)</code> in CJS).</p>

<p>Dynamic routers are really handy to avoid loading all possible routes and views up front, helps with performance.</p>

<p>Using the module ID via <code>module.id</code> is useful in cases where there are global spaces, like the DOM, and the module wants to construct class names, DOM data that will be in that global space. Basing its values on the module ID helps scope selectors and data access for that module.</p>

<h3 id="nostaticdefinitiontoallowinlinemodules">No static definition to allow inline modules</h3>

<p>This is a big missing piece in ES. Right now, expect to use AMD/CJS approaches here.</p>

<h2 id="hazardsonthewaytodone">Hazards on the way to done</h2>

<p>So, do not consider the ES module system done that with the publication of the ES6 spec. It just has one part of the system, and in many ways the most straight-forward piece. It is somewhat complicated by all the forms for <code>export</code> and <code>import</code>, but that was a design choice given TC-39's goals.</p>

<p>The real action comes with the module loader parts: if that is worked out, you might be able to skip the ES6 static definition parts.</p>

<p>So hopefully the other parts of the module system will come along. Some hazards to avoid on the way:</p>

<ul>
<li>Module IDs are not kept separate from paths/URLs, or if the loader uses paths/URLs instead of IDs for its internal keys.</li>
<li>No solid story for inline modules.</li>
<li>You need a script loader bootstrap even for the most basic wiring of all of the three pieces together.</li>
<li>The module loader needs a two-stage loading mechanism where the first stage loads up all possible loader lifecycle plugins before starting the second stage to load regular modules.</li>
<li>The <code>&lt;module&gt;</code> tag in HTML comes into existence before the module loader. Keeping with the extensible web philosophy, the module tag should just fall out of the module loader primitive and perhaps custom elements.</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS">CORS</a> configuration is required to use plain JS modules across domains. CORS should only be required if the <code>translate</code> loader lifecycle hook wants to look at it. Otherwise, the <code>translate</code> hook is skipped for those scripts.</li>
</ul>

<h2 id="summary">Summary</h2>

<p>Making a module system for ES is hard, and it is not done yet. I wish the process would have been different to date with more dialog outside of TC-39. However, it seems like the people working on it are just not done with all the pieces. I can appreciate it is hard to talk about it until the fuller picture is worked out.</p>

<p>The unfortunate part for me is seeing people starting to use the ES6 static module definition and transpiling to ES5 module systems to ship code. I think it is just too early to do that.</p>

<p>In the grand tradition of languages that can transpile to JS, you can get something to work and ship code to users. You can use CoffeeScript too. So if you are having fun with the transpiling route, that is great. Just know the sharp edges.</p>

<p>You are adding another layer of abstraction on top, and in the case of modules, you will likely need to directly use or know the properties of the ES5 module system you are using underneath to get the full breadth of module system functionality.</p>

<p>For me, fewer layers of abstraction are better. I will be waiting until more of the ES pieces are defined and shown to work well together before considering them done and using it to ship code.</p>
        </div>
    </div>

<div class="footer">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 560 980 324">
      <a xlink:href="./" title="home">
        	<path class="logoJ" d="M266.127,682.673c-0.123-0.143-3.178-0.303-7.709-0.123l-56.63,0.061l0.093-58.319h-64.494v58.195l-27.488-0.026
	c-1.322-0.053-2.649-0.087-3.985-0.087c-53.177,0-96.285,43.109-96.285,96.285s43.107,96.285,96.285,96.285
	c53.178,0,95.92-43.873,95.92-97.05c0-2.002-0.068-3.986-0.187-5.955l0.05-31.559l37.603-0.346
	c6.609,0.151,13.228-2.215,18.28-7.289C268.131,722.151,266.304,682.878,266.127,682.673z"/>
              <ellipse class="logoDotSpace" cx="169.783" cy="605.491" rx="38.463" ry="38.514"/>
              <circle class="logoDot" cx="169.678" cy="605.652" r="32.095"/>
              <path class="logoLoopSpace" d="M127.305,801.112c-12.627,12.44-33.318,11.246-45.355-1.765c-12.036-13.012-11.4-33.486,1.765-45.355c15.351-13.841,53.381-14.177,53.868-13.623C137.795,740.612,140.108,788.498,127.305,801.112z"/>
          <text x="331.3832" y="737.5167" class="emphasized" font-size="70">&copy;2012-2018</text>
        </a>
    </svg>
</div>
</body>
</html>
